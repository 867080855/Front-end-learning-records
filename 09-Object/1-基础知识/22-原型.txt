原型的产生：
    既然构造函数本身就可以定义属性和方法，为什么还要单独定义
一个原型对象呢？
    相同的对象中往往有一些相同的方法存在，为了减少代码的复用性，
减少内存的重复占用，产生了一个源性对象
    这样的话，只需要更改原型对象一个地方就可以完成所有地方的修改
================================================
属性共享理论：
    此处属性包括属性+方法
    原型对象不管实例化多少次都只会生成一次
================================================
注意：
    实例化的过程拷贝的是构造函数的所有内容，原型中的内容是不拷贝的
    那么原型中的内容为什么可以被正常访问呢？
        在构造函数拷贝过程中，会产生一个指针，指针中有一个地址值，
    指向原型对象
============================================
属性搜索机制(原型链)：
    1. 先在自身的属性列表中寻找
    2. 在自身的隐藏属性(prototype)中寻找,
    prototype属性中保存有原型对象的地址,将实例和原型对象联系到了一起

